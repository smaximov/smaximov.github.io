<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Peg | Без названия]]></title>
  <link href="http://blog.smaximov.info/blog/categories/peg/atom.xml" rel="self"/>
  <link href="http://blog.smaximov.info/"/>
  <updated>2014-04-11T21:46:07+11:00</updated>
  <id>http://blog.smaximov.info/</id>
  <author>
    <name><![CDATA[Сергей Максимов]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Разбор выражений с помощью PEG]]></title>
    <link href="http://blog.smaximov.info/blog/2014/04/08/parsing-expressions-with-peg-dot-js/"/>
    <updated>2014-04-08T17:46:00+11:00</updated>
    <id>http://blog.smaximov.info/blog/2014/04/08/parsing-expressions-with-peg-dot-js</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section">Синтаксический анализ</a>    <ul>
      <li><a href="#section-1">Формальная грамматика</a></li>
      <li><a href="#parsing-expression-grammars">Parsing Expression Grammars</a></li>
    </ul>
  </li>
  <li><a href="#pegjs">Генератор парсеров PEG.js</a></li>
  <li><a href="#section-2">Разбор языка логических выражений</a>    <ul>
      <li><a href="#section-3">Грамматика языка</a></li>
    </ul>
  </li>
  <li><a href="#section-4">Заключение</a></li>
  <li><a href="#section-5">Демонстрация</a></li>
  <li><a href="#section-6">Ссылки</a></li>
</ul>

<p>Давным давно<s>, в далёк</s> я
<a href="http://www.cyberforum.ru/post5772306.html">написал</a> код вычисления
логических выражений — просто так, задача интересной показалась.
Для этой цели был написан парсер, который преобразует строку с
логическим выражением в дерево, которое впоследствии вычисляется.
Теперь же захотелось подробно описать (для себя и для потомков), что
же при этом происходило.</p>

<p>В этом посте будет кратко затронуты понятия синтаксического анализа,
формальных грамматик, а также показан синтаксический разбор небольшого
языка с помощью PEG-парсера.</p>

<!-- more -->

<h1 id="section">Синтаксический анализ</h1>

<p>Синтаксический анализ, или <em>парсинг</em>, — это процесс анализа
последовательности символов (<em>строка</em>) какого-нибудь абстрактного <em>алфавита</em>
в соответствии правилами <em>формальной грамматики</em>. В процессе такого
анализа выявляется принадлежность этой строки определённому
<em>формальному языку</em>, который задаётся правилами грамматики над данным
алфавитом.</p>

<h2 id="section-1">Формальная грамматика</h2>

<p>Другими словами, формальная грамматика представляет собой набор
правил, описывающих множество всех возможных строк, которые получены
из некоторого алфавита и принадлежат определённому языку.</p>

<h2 id="parsing-expression-grammars">Parsing Expression Grammars</h2>

<p>Parsing Expression Grammars (PEG) — это один из видов
грамматики, введённый Брайаном Фордом в 2004 году.</p>

<p>Синтаксис состоит из нескольких элементов:</p>

<ul>
  <li>
    <p>Множества <em>терминальных</em> символов, которые «буквально» могут
присутствовать в какой-либо строке языка (обычно обозначаются в виде
строки в одинарных кавычках: <code>'terminal'</code>);</p>
  </li>
  <li>
    <p>множества <em>нетерминальных</em> символов, которым соответствуют группы
терминальных символов в соответствии с некоторыми правилами вывода;
нетерминалы также называют <em>синтаксическими переменными</em>
(обозначаются в виде строки без кавычек: <code>nonterminal</code>);</p>
  </li>
  <li>
    <p>множество <em>правил вывода</em>, которые показывают, как образуются
нетерминалы из терминалов и других нетерминалов;</p>
  </li>
  <li>
    <p>начального <em>выражения</em>.</p>
  </li>
</ul>

<p>Правила вывода имеют вид <code>nonterminal = some_expr</code>, где <code>some_expr</code>
— это <em>выражение</em>. Выражения можно определить по индукции:</p>

<ul>
  <li>
    <p><em>атомарное выражение</em> может состоять из любого терминала,
нетерминала или пустой строки;</p>
  </li>
  <li>
    <p>имея два выражения <em>e<sub>1</sub></em> и <em>e<sub>2</sub></em>, можно построить
новое выражение:</p>

    <ul>
      <li>
        <p><em>e<sub>1</sub></em> <em>e<sub>2</sub></em>: <em>последовательность</em> —
сначала идёт разбор <em>e<sub>1</sub></em>, потом (в случае успешности
разбора <em>e<sub>1</sub></em>) разбор <em>e<sub>2</sub></em>, в случае
неудачи разбора любого подвыражение разбор всего выражения
считается неудачным;</p>
      </li>
      <li>
        <p><em>e<sub>1</sub><sup>*</sup></em>, <em>e<sub>1</sub><sup>+</sup></em>,
<em>e<sub>1</sub>?</em>: <em>ноль или больше</em>, <em>один или больше</em>, <em>ноль или
один</em> раз выполняют разбор выражения <em>e<sub>1</sub></em>;</p>
      </li>
      <li>
        <p><em>e<sub>1</sub> / e<sub>2</sub></em>: <em>упорядоченный выбор</em> —
если <em>e<sub>1</sub></em> успешно, то происходит возврат, в противном
случае парсер откатывается назад и пытается выполнить разбор
<em>e<sub>2</sub></em>;</p>
      </li>
      <li>
        <p><em>&amp;e<sub>1</sub></em>: <em>и-предикат</em> —
разбор выполняется успешно, если выражение
<em>e<sub>1</sub></em> возвращает успех, но при этом парсер
не поглощает ввод;</p>
      </li>
      <li>
        <p><em>!e<sub>1</sub></em>: <em>не-предикат</em> — разбор выполняется
успешно, если выражение <em>e<sub>1</sub></em> возвращает неуспех;
парсер также не поглощает ввод.</p>
      </li>
    </ul>
  </li>
</ul>

<h1 id="pegjs">Генератор парсеров PEG.js</h1>

<p>Для данного примера мы рассмотрим парсер, который сгенерирован из
грамматики на PEG-like языке с помощью генератора PEG.js. Синтаксис
грамматик, принимаемых PEG.js, напоминает синстаксис PEG и вводит
несколько расширений. Рассмотрим вкратце некоторые из них.</p>

<ul>
  <li>
    <p>Каждое выражение грамматики помимо сопоставления с входным текстом
возвращает какой-либо результат в виде значения Javascript. Для
терминалов это сам совпавший текст, для повторений (<em>ноль или
много</em>, <em>один или много</em>) это массив результатов каждого
сопоставления выражения, для выражений-<em>предикатов</em> —
<code>undefined</code> и т. д.</p>
  </li>
  <li>
    <p><em>блок инициализации</em> — блок кода на Javascript, заключённый в
фигурные скобки, опционально предшествующий описанию правил вывода и
выполняемый перед непосредственным разбором; в основном используется
для определений функций и классов, необходимых для построения
синтаксического дерева.</p>
  </li>
  <li>
    <p><em>символьный класс</em> (<code>[characters]</code>) — выражение, описывающее
сопоставление символа входного текста какому-нибудь из символов в множестве,
заданном в символьном классе. Множество может быть задано простым
перечислением символов, диапазоном символов (<code>[a-z]</code>), инверсией
символов в множестве с помощью предшествующего символа <code>^</code>
(<code>[^a-z]</code>). Результатом выражения является совпавший символ.</p>
  </li>
  <li>
    <p><em>семантические действия</em> — выражение, представляющее собой
блок кода в фигурных скобках, который выполняется, если
предшествующее выражение совпало, и полученный результат
возвращается в качестве результата предшествующего выражения.</p>
  </li>
  <li>
    <p><em>подвыражение</em> — одно или несколько выражений, сгруппированных
с помощью круглых скобок.</p>
  </li>
  <li>
    <p><em>метка</em> — Javascript-идентификатор, присвоенный выражению (в
виде <code>label:expression</code>) и позволяющий ссылаться на результат
этого выражения внутри семантического действия.</p>
  </li>
</ul>

<p>Смысл и назначение этих расширений должны быть интуитивно понятны
читателю; в противном случае стоит подробнее ознакомиться с
<a href="http://pegjs.majda.cz/documentation#grammar-syntax-and-semantics">документацией</a>
к генератору.</p>

<h1 id="section-2">Разбор языка логических выражений</h1>

<p>Наш язык состоит из следующих элементов:</p>

<ul>
  <li>
    <p>булевы константы: <code>true</code> и <code>yes</code> — истина, <code>false</code> и <code>no</code> — ложь;</p>
  </li>
  <li>
    <p>переменные (идентификаторы, состоящие из строчных букв латинского алфавита);</p>
  </li>
  <li>
    <p>пробелы (игнорируются);</p>
  </li>
  <li>
    <p>скобки для задания приоритета вычислений;</p>
  </li>
  <li>
    <p>левоассоциативные операторы <code>&amp;</code> (конъюнкция) и <code>|</code> (дизъюнкция) с одинаковым приоритетом;</p>
  </li>
  <li>
    <p>унарный оператор <code>!</code> (отрицание), обладающий наивысшим приоритетом.</p>
  </li>
</ul>

<h2 id="section-3">Грамматика языка</h2>

<p>Сначала идёт блок инициализации, в котором объявляются узлы
синтаксического дерева, которое строится в процессе разбора входной
строки. Каждый узел обладает методом <code>evaluate</code>, принимающим словарь
окружения (<code>env</code>), содержащий привязки переменных, и вычисляющим
значение соответствующего узлу подвыражения.</p>

<p>``` javascript
{
  function BooleanLiteral (value) {
    this.evaluate = function () {
      return value;
    };
  }</p>

<p>function Variable (variable) {
    variable = variable.join(‘’);
    this.evaluate = function (env) {
      if (!(variable in env)) {
        throw new Error(“Undefined variable `” + variable + “’”);
      }</p>

<pre><code>  var value = env[variable];
  if ((/^(yes|true)$/).test(value)) return true;
  if ((/^(no|false)$/).test(value)) return false;

  throw new Error("Variable `" + variable + "' is not a boolean: " + value);
}   }
</code></pre>

<p>function Negate (arg) {
    this.evaluate = function (env) {
      return !arg.evaluate(env);
    };
  }</p>

<p>var dispatch = {
    ‘&amp;’: function (a, b) { return a &amp;&amp; b },
    ‘|’: function (a, b) { return a || b }
  }</p>

<p>function BinOp (op1, o, op2) {
    this.evaluate = function (env) {
      return dispatch<a href="op1.evaluate(env), op2.evaluate(env)">o</a>;
    }
  }
}
```</p>

<p>Следом идут определения правил вывода для нетерминалов. Нетерминал
<code>space</code> (пробельные символы) — это произвольное количество
пробелов:</p>

<p><code>
space
  = ' '*
</code></p>

<p>Булева константа (<code>literal</code>):</p>

<p><code>
literal
  = space ('true'/'yes') space { return new BooleanLiteral(true); }
  / space ('false'/'no') space { return new BooleanLiteral(false); }
</code></p>

<p>Переменная (<code>variable</code>):</p>

<p><code>
variable "variable" // lowercase letters
  = space letters:[a-z]+ space { return new Variable(letters); }
</code></p>

<p><code>primary</code>-выражение — описывает любой из следующих вариантов
— константа, переменная или выражение в скобках:</p>

<p><code>
primary
  = literal
  / variable
  / space '(' space expr:expr space ')' space { return expr; }
</code></p>

<p><code>negate</code> — сопоставление с символом оператора логического
отрицания:</p>

<p><code>
negate
  = space '!' space
</code></p>

<p><code>term</code> — <code>primary</code> выражение, которому может предшествовать
логическое отрицание:</p>

<p><code>
term
  = negate arg:(primary) { return new Negate(arg) }
  / primary
</code></p>

<p><code>op</code> — выражение, которое возвращает один из совпавших бинарных
операторов (конъюнкция или дизъюнкция):</p>

<p><code>
op
  = space o:('&amp;' / '|') space { return o; }
</code></p>

<p>И, наконец, правило для разбора всего логического выражения:</p>

<p><code>
expr
  = head:term rest:(op term)* {
    var res = head;
    rest.forEach(function (elements) {
      res = new BinOp(res, elements[0], elements[1]);
    });
    return res;
  }
</code></p>

<p>Тут, наверное, понадобятся пояснения. Для начало избавимся от
семантических действий и меток:</p>

<p><code>
expr
  = term (op term)*
</code></p>

<p>Выражение <code>expr</code> — это одно или несколько выражений <code>term</code>,
разделённых бинарными операторами.</p>

<p>Рассмотрим это правило на примере разбора выражения <code>x &amp; no | z</code>.</p>

<p>В процессе разбора выражению <code>term</code> сопоставится фрагмент <code>x</code>, а
выражению <code>(op term)*</code> — <code>&amp; no | z</code>. Введём метки:</p>

<p><code>
expr
  = head:term rest:(op term)*
</code></p>

<p>При разборе меткам присвоятся следующие значения:</p>

<p><code>
head: Varible(x)
rest: [ ['&amp;', BooleanLiteral(no)] , ['|', Variable(z)] ]
</code></p>

<p>Рассмотрим синтаксическое действие:</p>

<p><code>javascript
{
  var res = head;
  rest.forEach(function (elements) {
    res = new BinOp(res, elements[0], elements[1]);
  });
  return res;
}
</code></p>

<p>Человеку, знакомому с Javascript, будет понятно, что этот код строит
дерева разбора начиная с метки <code>head</code> снизу вверх. Примерный вид
полученного в результате дерева:</p>

<p><code>
                 +––––––––––+
              +––+BinOp: '|'+––+
              |  +––––––––––+  |
              |                |
              |                |
              |                |
         +––––+–––––+    +–––––+–––––+
      +––+BinOp: '&amp;'+–+  |Variable: z|
      |  +––––––––––+ |  +–––––––––––+
      |               |
      |               |
      |               |
      |               |
+–––––+–––––+    +––––+–––––––––––––+
|Variable: x|    |BooleanLiteral: no|
+–––––––––––+    +––––––––––––––––––+
</code></p>

<p>Теперь по поводу того, почему это правило имеет именно такой вид.
Конечно же, мы могли бы сделать так:</p>

<p><code>
expr
  = expr op term
  / term
</code></p>

<p>Однако это заставило бы парсер уйти в бесконечную рекурсию: парсер
видит правило <code>expr</code>, начинает сопоставлять выражение с первого
подвыражения (<code>expr</code>), в результате чего опять переходит на разбор
правила <code>expr</code>, и этот переход повторяется вновь и вновь. Такая
ситуация называется <em>левой рекурсией</em> (т. е., правила вида <code>a = a b</code>),
и некоторые генераторы парсеров могут самостоятельно разрешать такие
правила, однако PEG-парсеры к их числу не относятся.</p>

<p>Один из способов разрешить левую рекурсию — перейти к правой
рекурсии:</p>

<p><code>
expr
  = term op expr
  / term
</code></p>

<p>При этом возникает другая проблема — результирующее дерева
разбора растёт в сторону правой ветви, а не левой, что соответствует
правоассоциативным операторам (а не левоассоциативным, как у нас).
Иногда такое поведение и требуется изначально, но только не в нашем
случае.</p>

<h1 id="section-4">Заключение</h1>

<p>Данный пост не претендует на всеобъемлющий охват такой обширной темы,
как синтаксический анализ. Многие проблемы (классификация грамматик,
деревья разбора, абстрактные синтаксические деревья, левая рекурсия,
управление приоритетом и ассоциативностью операций и проч.) были
затронуты лишь поверхностно или вообще оставлены за кадром (во многом
по той причине, что я сам не достаточно хорошо владею описываемым
вопросом); для тех, кто хочет подробно ознакомиться с этими понятиями,
существует большое количество высококачественной литературы (список
которой, наверное, я когда-нибудь включу в этот пост).</p>

<p>Я же хотел продемонстрировать мощь генераторов парсеров (в данном
случае генератора PEG-парсера) в такой часто встречающейся задаче, как
разбор текста. Представленные в данном посте понятия и методики
позволяют при желании легко расширить наш язык выражений, добавив
новые операторы или даже управляющие конструкции.</p>

<h1 id="section-5">Демонстрация</h1>

<p>Для демонстрации я написал простую мордочку на Bootstrap и AngularJS:</p>

<p><small>
    Нажмите <a href="http://demos.smaximov.info/peg" target="_blank">сюда</a>,
    если iframe ниже не отображается.
</small></p>

<iframe src="http://demos.smaximov.info/peg" height="570" width="100%" style="border-radius: 5px; border: 1px #E0E0E0 groove">
    Your browser doesn't support iframes, sorry :(
</iframe>

<h1 id="section-6">Ссылки</h1>

<ul>
  <li><a href="https://github.com/smaximov/expression-peg-example">Исходный код примера</a></li>
</ul>
]]></content>
  </entry>
  
</feed>
