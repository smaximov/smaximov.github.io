---
layout: post
title: "Разбор выражений с помощью PEG"
date: 2014-04-08 17:46
comments: true
categories:
    - Javascript
    - Peg
    - Parsing
---

* TOC
{:toc}

Давным давно<s>, в далёк</s> я
[написал](http://www.cyberforum.ru/post5772306.html) код вычисления
логических выражений &mdash; просто так, задача интересной показалась.
Для этой цели был написан парсер, который преобразует строку с
логическим выражением в дерево, которое впоследствии вычисляется.
Теперь же захотелось подробно описать (для себя и для потомков), что
же при этом происходило.

В этом посте будет кратко затронуты понятия синтаксического анализа,
формальных грамматик, а также показан синтаксический разбор небольшого
языка с помощью PEG-парсера.

<!-- more -->

# Синтаксический анализ

Синтаксический анализ, или *парсинг*, &mdash; это процесс анализа
последовательности символов (*строка*) какого-нибудь абстрактного *алфавита*
в соответствии правилами *формальной грамматики*. В процессе такого
анализа выявляется принадлежность этой строки определённому
*формальному языку*, который задаётся правилами грамматики над данным
алфавитом.

## Формальная грамматика

Другими словами, формальная грамматика представляет собой набор
правил, описывающих множество всех возможных строк, которые получены
из некоторого алфавита и принадлежат определённому языку.

## Parsing Expression Grammars

Parsing Expression Grammars (PEG) &mdash; это один из видов
грамматики, введённый Брайаном Фордом в 2004 году.

Синтаксис состоит из нескольких элементов:

* Множества *терминальных* символов, которые <<буквально>> могут
  присутствовать в какой-либо строке языка (обычно обозначаются в виде
  строки в одинарных кавычках: `'terminal'`);

* множества *нетерминальных* символов, которым соответствуют группы
  терминальных символов в соответствии с некоторыми правилами вывода;
  нетерминалы также называют *синтаксическими переменными*
  (обозначаются в виде строки без кавычек: `nonterminal`);

* множество *правил вывода*, которые показывают, как образуются
  нетерминалы из терминалов и других нетерминалов;

* начального *выражения*.

Правила вывода имеют вид `nonterminal = some_expr`, где `some_expr`
&mdash; это *выражение*. Выражения можно определить по индукции:

* *атомарное выражение* может состоять из любого терминала,
  нетерминала или пустой строки;

* имея два выражения *e<sub>1</sub>* и *e<sub>2</sub>*, можно построить
  новое выражение:

    * *e<sub>1</sub>* *e<sub>2</sub>*: *последовательность* &mdash;
      сначала идёт разбор *e<sub>1</sub>*, потом (в случае успешности
      разбора *e<sub>1</sub>*) разбор *e<sub>2</sub>*, в случае
      неудачи разбора любого подвыражение разбор всего выражения
      считается неудачным;

    * *e<sub>1</sub><sup>\*</sup>*, *e<sub>1</sub><sup>+</sup>*,
      *e<sub>1</sub>?*: *ноль или больше*, *один или больше*, *ноль или
      один* раз выполняют разбор выражения *e<sub>1</sub>*;

    * *e<sub>1</sub> / e<sub>2</sub>*: *упорядоченный выбор* &mdash;
      если *e<sub>1</sub>* успешно, то происходит возврат, в противном
      случае парсер откатывается назад и пытается выполнить разбор
      *e<sub>2</sub>*;

    * *&e<sub>1</sub>*: *и-предикат* &mdash;
      разбор выполняется успешно, если выражение
      *e<sub>1</sub>* возвращает успех, но при этом парсер
      не поглощает ввод;

    * *!e<sub>1</sub>*: *не-предикат* &mdash; разбор выполняется
      успешно, если выражение *e<sub>1</sub>* возвращает неуспех;
      парсер также не поглощает ввод.

# Генератор парсеров PEG.js

Для данного примера мы рассмотрим парсер, который сгенерирован из
грамматики на PEG-like языке с помощью генератора PEG.js. Синтаксис
грамматик, принимаемых PEG.js, напоминает синстаксис PEG и вводит
несколько расширений. Рассмотрим вкратце некоторые из них.

* Каждое выражение грамматики помимо сопоставления с входным текстом
  возвращает какой-либо результат в виде значения Javascript. Для
  терминалов это сам совпавший текст, для повторений (*ноль или
  много*, *один или много*) это массив результатов каждого
  сопоставления выражения, для выражений-*предикатов* &mdash;
  `undefined` и т. д.

* *блок инициализации* &mdash; блок кода на Javascript, заключённый в
  фигурные скобки, опционально предшествующий описанию правил вывода и
  выполняемый перед непосредственным разбором; в основном используется
  для определений функций и классов, необходимых для построения
  синтаксического дерева.

* *символьный класс* (`[characters]`) &mdash; выражение, описывающее
  сопоставление символа входного текста какому-нибудь из символов в множестве,
  заданном в символьном классе. Множество может быть задано простым
  перечислением символов, диапазоном символов (`[a-z]`), инверсией
  символов в множестве с помощью предшествующего символа `^`
  (`[^a-z]`). Результатом выражения является совпавший символ.

* *семантические действия* &mdash; выражение, представляющее собой
  блок кода в фигурных скобках, который выполняется, если
  предшествующее выражение совпало, и полученный результат
  возвращается в качестве результата предшествующего выражения.

* *подвыражение* &mdash; одно или несколько выражений, сгруппированных
  с помощью круглых скобок.

* *метка* &mdash; Javascript-идентификатор, присвоенный выражению (в
  виде `label:expression`) и позволяющий ссылаться на результат
  этого выражения внутри семантического действия.

Смысл и назначение этих расширений должны быть интуитивно понятны
читателю; в противном случае стоит подробнее ознакомиться с
[документацией](http://pegjs.majda.cz/documentation#grammar-syntax-and-semantics)
к генератору.

# Разбор языка логических выражений

Наш язык состоит из следующих элементов:

* булевы константы: `true` и `yes` — истина, `false` и `no` — ложь;

* переменные (идентификаторы, состоящие из строчных букв латинского алфавита);

* пробелы (игнорируются);

* скобки для задания приоритета вычислений;

* левоассоциативные операторы `&` (конъюнкция) и `|` (дизъюнкция) с одинаковым приоритетом;

* унарный оператор `!` (отрицание), обладающий наивысшим приоритетом.


## Грамматика языка

Сначала идёт блок инициализации, в котором объявляются узлы
синтаксического дерева, которое строится в процессе разбора входной
строки. Каждый узел обладает методом `evaluate`, принимающим словарь
окружения (`env`), содержащий привязки переменных, и вычисляющим
значение соответствующего узлу подвыражения.

``` javascript
{
  function BooleanLiteral (value) {
    this.evaluate = function () {
      return value;
    };
  }

  function Variable (variable) {
    variable = variable.join('');
    this.evaluate = function (env) {
      if (!(variable in env)) {
        throw new Error("Undefined variable `" + variable + "'");
      }

      var value = env[variable];
      if ((/^(yes|true)$/).test(value)) return true;
      if ((/^(no|false)$/).test(value)) return false;

      throw new Error("Variable `" + variable + "' is not a boolean: " + value);
    }
  }

  function Negate (arg) {
    this.evaluate = function (env) {
      return !arg.evaluate(env);
    };
  }

  var dispatch = {
    '&': function (a, b) { return a && b },
    '|': function (a, b) { return a || b }
  }

  function BinOp (op1, o, op2) {
    this.evaluate = function (env) {
      return dispatch[o](op1.evaluate(env), op2.evaluate(env));
    }
  }
}
```

Следом идут определения правил вывода для нетерминалов. Нетерминал
`space` (пробельные символы) &mdash; это произвольное количество
пробелов:

```
space
  = ' '*
```

Булева константа (`literal`):

```
literal
  = space ('true'/'yes') space { return new BooleanLiteral(true); }
  / space ('false'/'no') space { return new BooleanLiteral(false); }
```

Переменная (`variable`):

```
variable "variable" // lowercase letters
  = space letters:[a-z]+ space { return new Variable(letters); }
```

`primary`-выражение &mdash; описывает любой из следующих вариантов
&mdash; константа, переменная или выражение в скобках:

```
primary
  = literal
  / variable
  / space '(' space expr:expr space ')' space { return expr; }
```

`negate` &mdash; сопоставление с символом оператора логического
отрицания:

```
negate
  = space '!' space
```

`term` &mdash; `primary` выражение, которому может предшествовать
логическое отрицание:

```
term
  = negate arg:(primary) { return new Negate(arg) }
  / primary
```

`op` &mdash; выражение, которое возвращает один из совпавших бинарных
операторов (конъюнкция или дизъюнкция):

```
op
  = space o:('&' / '|') space { return o; }
```

И, наконец, правило для разбора всего логического выражения:

```
expr
  = head:term rest:(op term)* {
    var res = head;
    rest.forEach(function (elements) {
      res = new BinOp(res, elements[0], elements[1]);
    });
    return res;
  }
```

Тут, наверное, понадобятся пояснения. Для начало избавимся от
семантических действий и меток:

```
expr
  = term (op term)*
```

Выражение `expr` &mdash; это одно или несколько выражений `term`,
разделённых бинарными операторами.

Рассмотрим это правило на примере разбора выражения `x & no | z`.

В процессе разбора выражению `term` сопоставится фрагмент `x`, а
выражению `(op term)*` &mdash; `& no | z`. Введём метки:

```
expr
  = head:term rest:(op term)*
```

При разборе меткам присвоятся следующие значения:

```
head: Varible(x)
rest: [ ['&', BooleanLiteral(no)] , ['|', Variable(z)] ]
```

Рассмотрим синтаксическое действие:

``` javascript
{
  var res = head;
  rest.forEach(function (elements) {
    res = new BinOp(res, elements[0], elements[1]);
  });
  return res;
}
```

Человеку, знакомому с Javascript, будет понятно, что этот код строит
дерева разбора начиная с метки `head` снизу вверх. Примерный вид
полученного в результате дерева:

```
                 +––––––––––+
              +––+BinOp: '|'+––+
              |  +––––––––––+  |
              |                |
              |                |
              |                |
         +––––+–––––+    +–––––+–––––+
      +––+BinOp: '&'+–+  |Variable: z|
      |  +––––––––––+ |  +–––––––––––+
      |               |
      |               |
      |               |
      |               |
+–––––+–––––+    +––––+–––––––––––––+
|Variable: x|    |BooleanLiteral: no|
+–––––––––––+    +––––––––––––––––––+
```

Теперь по поводу того, почему это правило имеет именно такой вид.
Конечно же, мы могли бы сделать так:

```
expr
  = expr op term
  / term
```

Однако это заставило бы парсер уйти в бесконечную рекурсию: парсер
видит правило `expr`, начинает сопоставлять выражение с первого
подвыражения (`expr`), в результате чего опять переходит на разбор
правила `expr`, и этот переход повторяется вновь и вновь. Такая
ситуация называется *левой рекурсией* (т. е., правила вида `a = a b`),
и некоторые генераторы парсеров могут самостоятельно разрешать такие
правила, однако PEG-парсеры к их числу не относятся.

Один из способов разрешить левую рекурсию &mdash; перейти к правой
рекурсии:

```
expr
  = term op expr
  / term
```

При этом возникает другая проблема &mdash; результирующее дерева
разбора растёт в сторону правой ветви, а не левой, что соответствует
правоассоциативным операторам (а не левоассоциативным, как у нас).
Иногда такое поведение и требуется изначально, но только не в нашем
случае.

# Заключение

Данный пост не претендует на всеобъемлющий охват такой обширной темы,
как синтаксический анализ. Многие проблемы (классификация грамматик,
деревья разбора, абстрактные синтаксические деревья, левая рекурсия,
управление приоритетом и ассоциативностью операций и проч.) были
затронуты лишь поверхностно или вообще оставлены за кадром (во многом
по той причине, что я сам не достаточно хорошо владею описываемым
вопросом); для тех, кто хочет подробно ознакомиться с этими понятиями,
существует большое количество высококачественной литературы (список
которой, наверное, я когда-нибудь включу в этот пост).

Я же хотел продемонстрировать мощь генераторов парсеров (в данном
случае генератора PEG-парсера) в такой часто встречающейся задаче, как
разбор текста. Представленные в данном посте понятия и методики
позволяют при желании легко расширить наш язык выражений, добавив
новые операторы или даже управляющие конструкции.

# Демонстрация

Для демонстрации я написал простую мордочку на Bootstrap и AngularJS:

<small>
    Нажмите [сюда](http://demos.smaximov.info/peg){:target="_blank"},
    если iframe ниже не отображается.
</small>

<iframe src="http://demos.smaximov.info/peg" height="570" width="100%"
        style="border-radius: 5px; border: 1px #E0E0E0 groove">
    Your browser doesn't support iframes, sorry :(
</iframe>

# Ссылки

* [Исходный код примера](https://github.com/smaximov/expression-peg-example)
