---
layout: post
title: "Cabal sandbox и direnv"
date: 2014-07-15 17:26
keywords: "cabal, direnv, zsh, shell"
comments: true
categories:
- Cabal
- direnv
- Zsh
---

* TOC
{:toc}

Cabal на текущий момент имеет очень серьёзный недостаток: он не
поддерживает одновременной установки различных версий одного и того же
пакета. В результате мы имеем ситуацию, когда обновление версии
какого-нибудь пакета может привести к тому, что сломаются пакеты,
зависящие от старой версии этого пакета.

<!-- more -->

# `cabal sandbox` to rescue!

[Cabal Sandboxes](http://www.haskell.org/cabal/users-guide/installing-packages.html#developing-with-sandboxes)
&mdash; это относительно новая (начиная с версии 1.18) фича
cabal-install, призванная стать (временным) решением данной проблемы.

&laquo;Песочницы&raquo; позволяют создать изолированные окружения для
каждого пакета. Каждое такое окружение имеет свою собственную локальную базу
данных пакетов. Также окружение может ссылаться на пакет, который ещё
не был выпущен или на версию, которой нет в архиве пакетов.

## Инициализация

Для инициализации песочницы нужно выполнить следующую команду из
корневой директории проекта:

``` bash
cabal sandbox init
```

При этом будет сгенерирована директория `.cabal-sandbox`, в которой
будут установлены зависимости и результаты сборки пакета. Дальнейшие
команды `cabal` будут выполняться уже в контексте песочницы.

## Добавление локальной зависимости

`cabal sandbox` позволяет указать директорию, в которой находятся
исходные коды некоторого пакета, в качестве источника, откуда этот
пакет будет установлен в качестве зависимости.

Допустим, мы разрабатываем пакет `foo`, который зависит от пакета
`bar`. Представим себе, что пакета `bar` ещё нет на Hackage (или мы
пропатчили пакет `bar`, но патч ещё не отослали). Тогда можно указать
в песочнице пакета `foo`, чтобы пакет `bar` устанавливался не из
Hackage, а из исходников:

``` bash
# В корневой директории пакета foo
cabal sandbox add-source path/to/bar
# Установка зависимостей: bar будет установлен из path/to/bar
cabal install --dependencies-only
```

## Удаление песочницы

Для удаления песочницы и возврату к &laquo;обычному&raquo; режиму
Cabal нужно выполнить команду `cabal sandbox delete`. В качестве
альтернативы можно просто удалить файлы и директории песочницы:
`cabal.sandbox.config` и `.cabal-sandbox/`.

## Манипуляция `PATH`

Песочница устанавливает исполняемые файлы в поддиректорию
`.cabal-sandbox/bin` пакета. Для того, чтобы каждый раз не писать путь
к бинарникам, нужно модифицировать переменную окружения `PATH`.
Очевидный способ &mdash; добавить относительный путь
`.cabal-sandbox/bin` к переменной `PATH` в rc-файле шелла &mdash;
банален и неинтересен; рассмотрим вместо этого более гибкое решение,
которое может пригодиться и в других ситуациях.

# Специфичное для директории окружение

Нас интересует решение, которое позволяло бы в зависимости от текущей
директории иметь различное значение `PATH` (а в идеале и других
переменных окружения). Такого поведения можно добиться с помощью
утилиты [direnv](http://direnv.net/), написанной на Go. Direnv
встраивается в шелл и загружает и восстанавливает переменные окружения
при смене рабочей директории.

После установки утилиты её нужно добавить
следующую строчку (в случае Zsh, который я использую) в конец
rc-файла шелла:

``` bash
eval "$(direnv hook zsh)"
```

После этого в директории, которая требует специфических настроек
окружения, создаётся файл `.envrc`, который устанавливает и
экспортирует нужные переменные. Для нашего примера с песочницами это
был бы файл `.envrc` в корневой директории пакета со следующим
содержимым:

``` bash
export PATH="${PWD}/.cabal-sandbox/bin:${PATH}"
```
что эквивалентно следующей строке с использованием одной из
вспомогательных функций dirent:

``` bash
PATH_add .cabal-sandbox/bin
```

После этого нужно разрешить dirent выполнять содержимое `.envrc` в
этой директории:

``` bash
dirent allow .
```

В качестве альтернативы можно использовать команду

``` bash
dirent edit .
```

Она открывает `./.envrc` в редакторе `$EDITOR` и автоматически
разрешает этот файл после его изменения.

Теперь при входе в эту директорию переменные из `.envrc` будут
загружены в текущее окружение, а при выходе &mdash; выгружены.
